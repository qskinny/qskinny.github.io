<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QSkinny: Tutorials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- QSkinny WASM code -->
        <script type="text/javascript">
            async function docSampleInit()
            {
                const spinner = document.querySelector('#qtspinner');
                const screen = document.querySelector('#qt-wasm-screen');
                const status = document.querySelector('#qtstatus');
                const showUi = (ui) => {
                    [spinner, screen].forEach(element => element.style.display = 'none');
                    if (screen === ui)
                    {
                        screen.style.position = 'default';
                        screen.style.width = '500px';
                        screen.style.height = '300px';
                    }
                    ui.style.display = 'block';
                }
                try {
                    if(spinner)
                    {
                        showUi(spinner);
                        status.innerHTML = 'Loading...';
                        const instance = await qtLoad({
                            qt: {
                                onLoaded: () => showUi(screen),
                                onExit: exitData =>
                                {
                                    status.innerHTML = 'Application exit';
                                    status.innerHTML +=
                                        exitData.code !== undefined ? ` with code ` : '';
                                    status.innerHTML +=
                                        exitData.text !== undefined ? ` ()` : '';
                                    showUi(spinner);
                                },
                                entryFunction: window.createQtAppInstance,
                                containerElements: [screen],
                            }
                        });
                    }
                } catch (e) {
                    console.error(e);
                    console.error(e.stack);
                }
            }
        </script>
    <script type="text/javascript" src="apiDocumentationSamples.js"></script>
    <script type="text/javascript" src="qtloader.js"></script>
<!-- end QSkinny WASM code -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body onLoad="docSampleInit()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QSkinny<span id="projectnumber">&#160;0.8.0</span>
   </div>
   <div id="projectbrief">C++/Qt UI toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tutorials.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorials</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
What is QSkinny?</h1>
<p>QSkinny is a UI framework based on the Qt graphic stack and written in {cpp}. It allows users to write their UIs in {cpp} and/or QML.</p>
<p><b>The Fendt Tractor GUI</b></p>
<p><img src="https://www.fendt.com/at/geneva-assets/widget/28282/news-3-low.jpg" alt="Fendt Tractor GUI" class="inline"/></p>
<p>It is currently being used in the Fendt Tractor GUI project, see the picture above. For the Fendt Tractor GUI there is no QML used at all; the whole codebase is written in {cpp}. An overview of how QSkinny fits into the Qt architecture is depicted below:</p>
<p><b>QSkinny sits on top of QtQuick, while QML is optional</b></p>
<div class="image">
<img src="architecture-simple.png" alt=""/>
<div class="caption">
QSkinny architecture</div></div>
    <h1><a class="anchor" id="autotoc_md1"></a>
Why QSkinny?</h1>
<p>The typical questions about QSkinny are: Why was QSkinny created? And why would somebody use QSkinny and not QML?</p>
<p>Which technology to use always depends on the specific use case. However, QSkinny does have some advantages:</p>
<h2><a class="anchor" id="autotoc_md2"></a>
1. It's C++</h2>
<p>QSkinny is written in C++, so there is no new syntax or programming paradigm to learn as is the case with QML. Of course QSkinny has concepts that new programmers need to become familiar with, but they should be understandable for people who know C++. Especially programmers experienced with QtWidgets should feel comfortable with QSkinny right away.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
1.1 Integration with other build systems / IDEs</h3>
<p>While QtCreator is the natural choice of <b>IDE</b> for Qt programmers, some people prefer other IDEs, e.g. Visual Studio (Code), Eclipse, CLion etc. Such IDEs usually don’t have language support for QML like type completion and other features. So when using QML you are either bound to using QtCreator, or use another IDE and live with the fact that the IDE will not understand QML.</p>
<p>When it comes to <b>build systems</b>, some QML tools might be hard to integrate: For instance in Visual Studio projects it is difficult to invoke the QML compiler through the build system.</p>
<p>With QSkinny being written completely in C++, it can be used with any IDE and should integrate nicely with other build systems. QSkinny is using Qt-specific concepts like signals and slots and invokable methods though.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
1.2 Use C++ tooling for your whole codebase</h3>
<p>C++ has extensive tooling that assists with writing code, for instance:</p>
<ul>
<li>gdb and other debuggers</li>
<li>valgrind</li>
<li>address sanitizer and other sanitizers</li>
<li>static code analysis tools</li>
<li>code coverage tools (e.g. gcov)</li>
<li>auto test frameworks</li>
<li>(a lot more, e.g. clang tools)</li>
</ul>
<p>E.g. QtCreator will let you know about potential problems in your code while you type, e.g. "unused variable", "calling a virtual method from the constructor
of a class" etc., and it might even suggest an automatic fix for it.</p>
<p>QML does have some tooling, but its feature set is nowhere near the support of C++.</p>
<p>When writing your whole codebase in C++ with QSkinny, the tooling can be used for the whole codebase, so also UI code can be debugged, auto tested for a CI system, and so on.</p>
<p>In addition, C++ has concepts that QML as a declarative language doesn’t, like inheritance and overloading. This makes it easier to implement concepts like event handling, see Styling below.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
2. Easy data binding</h2>
<p>When displaying data from a backend in a QML UI, that data needs to be in a certain format: It needs to be made readable by Qt’s Meta Object system via <code>Q_PROPERTY</code>, <code>Q_INVOKABLE</code>, <code>Q_SIGNAL</code> and others.</p>
<p>Also, for each model that is used in QML there typically needs to be one subclass of <code>QAbstractListModel</code>, which serves as an adapter class. The process of subclassing and implementing virtual methods can be cumbersome, and lead to lots of boilerplate code.</p>
<p>QSkinny doesn’t need any adaptation layer per se, the data just needs to be connected to the frontend with standard C++ functionality. Of course classes like the aforementioned <code>QAbstractListModel</code> can be used when it makes sense, but this is up to the user.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
3. Layouts</h2>
<p>Whe it comes to <b>layouts</b>, QSkinny has a complete concept of laying out the UI, or in other words: The user can determine in a fine-grained way what happens when there is too little or too much space available. Concepts like size hints, size policies, stretch factors and others are concepts that were already available in QtWidgets and Qt’s Graphics View Framework, and are now supported in QSkinny.</p>
<p>Why are layouts important? QML was created under the premise that in contrast to desktop UIs, embedded UIs run as fullscreen window on an embedded board and thus size changes will rarely happen.</p>
<p>This is true for many cases, however layout code gets important when one of the following events happen:</p>
<ul>
<li>The UI needs to run on two or more screen sizes</li>
<li>Language or style changes need to be supported</li>
<li>The window is resized, e.g. when the Android virtual keyboard pops up</li>
</ul>
<p>QSkinny allows the user to take the above use cases into account, but doesn’t force the developer to write overly complex code: A UI written with QSkinny can be coded with fixed sizes for UI elements, as it is typically done in QML.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
4. Styling / Adding custom controls</h2>
<p>Qt Quick Controls 2 support different styles, and it even comes with several built-in styles like a Google Material style and a Microsoft Universal style.</p>
<p>One drawback with Qt Quick Controls 2 is that application developers can only add custom types in QML, not in C++. This makes it cumbersome for concepts like event handling, as is noted in the Qt documentation: <a href="https://doc.qt.io/qt-5/qtquickcontrols2-differences.html">Differences with Qt Quick Controls 1</a>.</p>
<p>So an application developer who wants to add own types, as is common for medium to large-scale projects, will have to implement these custom types in QML. Since being able to use C++ for application logic of components seems to have been one reason to create Qt Quick Controls 2 (another reason apparently being performance issues with Qt Quick Controls 1), allowing the user to write controls in C++ gives the user more flexibility.</p>
<p>QSkinny allows for implementing custom types in C++; also both built-in components like push buttons, sliders etc. as well as custom types can be easily styled from C++. The latter can be achieved by simply adding style descriptions in user code.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Writing your first application</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Building the QSkinny repository</h2>
<p>In this chapter we will write a simple QSkinny application on Linux from scratch in C++ with Qt6. As a prerequisite, a supported Qt6 version should be available.</p>
<p>On debian bullseye we need to install these packages <code>build-essential cmake qtbase6-dev qtbase6-private-dev qtdeclarative6-dev qtdeclarative6-private-dev libqt6svg-dev qt6-shadertools</code>.</p>
<p>Optional packages for the virtual keyboard are <code>libhunspell-dev libimepinyin-dev</code></p>
<p>Then we can build and install QSkinny to <code>/opt/qskinny</code> with the following commands:</p>
<div class="fragment"><div class="line">$ git clone https://github.com/uwerat/qskinny.git # clone</div>
<div class="line">$ cd qskinny</div>
<div class="line">$ mkdir build &amp;&amp; cd build</div>
<div class="line">$ cmake ..</div>
<div class="line">$ cmake --build .</div>
<div class="line">$ sudo cmake --install . --prefix &quot;/opt/qskinny&quot;</div>
</div><!-- fragment --><p>Considering that you want to use a specific Qt version that is installed below "/path/to/qt" you have 2 options:</p>
<div class="fragment"><div class="line">$ cmake .. -DCMAKE_PREFIX_PATH=/path/to/qt</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">$ /path/to/qt/bin/qt-cmake ..</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Compiling our first app</h2>
<p>As a next step, we need to write our app. Let’s start with a simple <code>main.cpp</code> file in a directory <code>myapp</code>:</p>
<p><b>main.cpp</b></p>
<div class="fragment"><div class="line">#include &lt;QskWindow.h&gt;</div>
<div class="line">#include &lt;QGuiApplication&gt;</div>
<div class="line"> </div>
<div class="line">int main( int argc, char* argv[] )</div>
<div class="line">{</div>
<div class="line">    QGuiApplication app( argc, argv );</div>
<div class="line"> </div>
<div class="line">    QskWindow window;</div>
<div class="line">    window.show();</div>
<div class="line"> </div>
<div class="line">    return app.exec();</div>
<div class="line">}</div>
</div><!-- fragment --><p>For now this will just create an empty window (the <code><a class="el" href="classQskWindow.html">QskWindow</a></code>) without any controls. Next, we need to create a <code>CMakeLists.txt</code> file in our <code>myapp</code> directory.</p>
<p><b>CMakeLists.txt</b></p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.27)</div>
<div class="line"> </div>
<div class="line">project(myapp</div>
<div class="line">    VERSION 1.0.0</div>
<div class="line">    LANGUAGES CXX)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_CXX_STANDARD 17)</div>
<div class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_AUTOMOC ON)</div>
<div class="line">set(CMAKE_AUTORCC ON)</div>
<div class="line">set(CMAKE_AUTOUIC ON)</div>
<div class="line"> </div>
<div class="line">find_package(Qt6 REQUIRED COMPONENTS Quick)</div>
<div class="line">find_package(QSkinny REQUIRED)</div>
<div class="line"> </div>
<div class="line">add_executable(myapp</div>
<div class="line">    src/main.cpp)</div>
<div class="line"> </div>
<div class="line">target_link_libraries(myapp PRIVATE</div>
<div class="line">    Qt6::Quick</div>
<div class="line">    Qsk::QSkinny)</div>
</div><!-- fragment --><p>Now we can compile our app:</p>
<div class="fragment"><div class="line">$ cd myapp</div>
<div class="line">$ mkdir build &amp;&amp; cd build</div>
<div class="line">$ cmake ../ &amp;&amp; make</div>
</div><!-- fragment --><p>When running myapp it needs to find the skin plugins. Setting QT_PLUGIN_PATH is one option ( see <a href="https://doc.qt.io/qt/deployment-plugins.html">https://doc.qt.io/qt/deployment-plugins.html</a> ):</p>
<div class="fragment"><div class="line">$ QT_PLUGIN_PATH=/opt/qskinny/plugins ./myapp</div>
</div><!-- fragment --><p>This should show just an empty window.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Adding UI controls</h2>
<p>Now that we have our app running, we can add some UI controls to it by extending the <code>main.cpp</code> file we created earlier. We will add some additional include directives, and then create a horizontal layout containing two push buttons. The layout with the two buttons will be shown in the window. Below is the complete updated source file:</p>
<p><b>main.cpp</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;QskWindow.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;QskLinearBox.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;QskPushButton.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;QGuiApplication&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )</div>
<div class="line">{</div>
<div class="line">    QGuiApplication app( argc, argv );</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> box = <span class="keyword">new</span> <a class="code hl_class" href="classQskLinearBox.html">QskLinearBox</a>( Qt::Horizontal );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">        some design systems work with transparencies ( f.e Fluent2 )</span></div>
<div class="line"><span class="comment">        and we need to have a control providing a solid base color</span></div>
<div class="line"><span class="comment">        as bottom layer.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    box-&gt;setPanel( <span class="keyword">true</span> );</div>
<div class="line"> </div>
<div class="line">    (void) <span class="keyword">new</span> <a class="code hl_class" href="classQskPushButton.html">QskPushButton</a>( <span class="stringliteral">&quot;Button 1&quot;</span>, box );</div>
<div class="line">    (void) <span class="keyword">new</span> <a class="code hl_class" href="classQskPushButton.html">QskPushButton</a>( <span class="stringliteral">&quot;Button 2&quot;</span>, box );</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classQskWindow.html">QskWindow</a> window;</div>
<div class="line">    window.addItem( horizontalBox );</div>
<div class="line">    window.show();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> app.exec();</div>
<div class="line">}</div>
<div class="ttc" id="aclassQskLinearBox_html"><div class="ttname"><a href="classQskLinearBox.html">QskLinearBox</a></div><div class="ttdoc">Layout stringing items in rows and columns.</div><div class="ttdef"><b>Definition</b> <a href="QskLinearBox_8h_source.html#l00011">QskLinearBox.h:12</a></div></div>
<div class="ttc" id="aclassQskPushButton_html"><div class="ttname"><a href="classQskPushButton.html">QskPushButton</a></div><div class="ttdef"><b>Definition</b> <a href="QskPushButton_8h_source.html#l00015">QskPushButton.h:16</a></div></div>
<div class="ttc" id="aclassQskWindow_html"><div class="ttname"><a href="classQskWindow.html">QskWindow</a></div><div class="ttdef"><b>Definition</b> <a href="QskWindow_8h_source.html#l00016">QskWindow.h:17</a></div></div>
</div><!-- fragment --><p>Now the app is displaying the two buttons:</p>
<div class="image">
<img src="writing-first-application.png" alt=""/>
<div class="caption">
An app showing two buttons</div></div>
    <p>That’s it; you just created a QSkinny application from scratch.</p>
<p>For information on how the controls and layouts above behave, see the next chapters.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Layouts</h1>
<p>Layouts manage the position of UI elements on the screen, and how the elements react to size changes (e.g. window resize).</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Size hints</h2>
<p>Size hints let the layouting code know how big UI elements are, and to which size they may shrink or grow.</p>
<p>Size hints can be explicit or implicit. Explicit sizes are set by the user via an API call through <code>setExplicitSizeHint()</code> ("This element is
of that size"), while implicit sizes are deduced from the elements themselves. Explicit size hints always take precedence over implicit ones.</p>
<p>For instance, the implicit size of a button is calculated from the text width (which itself depends on the font) and possibly padding and margins:</p>
<p><b>implicit horizontal size hint of a button</b></p>
<div class="image">
<img src="size-hints-calculation.png" alt=""/>
<div class="caption">
implicit horizontal size hint of a button</div></div>
    <p>The implicit width of a composited UI element containing a graphic on the left and a text on the right would be the sum of the elements’ width, again with padding and margins.</p>
<p>Layouts, i.e. classes deriving from <code><a class="el" href="classQskBox.html">QskBox</a></code>, are also controls (i.e. <code><a class="el" href="classQskControl.html" title="Base class of all controls.">QskControl</a></code> instances), so they also have size hints. A layout typically calculates its implicit size hint by summing up the size of its children. For instace a horizontal layout containing three buttons next to each other will calculate its implicit width by summing up the widths of the buttons (spacing and margins again come on top).</p>
<p>There are three types of size hints: <b>Minimum</b>, <b>Preferred</b> and <b>Maximum</b>.</p>
<ul>
<li>The <b>minimum size hint</b> of a UI element is used by layouting code to determine how small an element can be.</li>
<li>The <b>preferred size hint</b> is the natural size of an element, and will be used in an ideal case, meaning there is enough space available.</li>
<li>The <b>maximum size hint</b> is used by layouting code to determine how big an element can be.</li>
</ul>
<p>Minimum and maximum size hints of atomic controls like <code><a class="el" href="classQskPushButton.html">QskPushButton</a></code> or <code><a class="el" href="classQskTextLabel.html">QskTextLabel</a></code> are typically not used, instead size policies are used to express how small or big a component can be (see next topic). Minimum and maximum sizes, i.e. the methods <code>minimumSize()</code> and <code>maximumSize()</code>, are typically used for layouts though.</p>
<p>So in total, a control can have up to 6 size hints: the three types described above, and each one can have an implicit and an explicit hint.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Example</h3>
<p>Below is an image with an implicit size hint with a width of 91 pixels and a height of 39 pixels (91x39). The hint is determined by the size of the text (71x19 pixels) plus margins (10 pixels each for top, right, bottom, left). We don’t need to set a size hint explicitly, the control will be rendered correctly with the implicit size hint:</p>
<div class="fragment"><div class="line">auto* label1 = new QskTextLabel( &quot;control 1&quot; );</div>
<div class="line">label1-&gt;setMargins( 10 );</div>
<div class="line">label1-&gt;setBackgroundColor( Qt::magenta );</div>
</div><!-- fragment --><p><b>control without explicit size hint</b></p>
<div class="image">
<img src="size-hints-1.png" alt=""/>
<div class="caption">
Image without explicit size hint</div></div>
    <p>If we set an explicit size hint of 150x60 pixels ourselves for the preferred size, the control will be rendered differently:</p>
<div class="fragment"><div class="line">label1-&gt;setExplicitSizeHint( Qt::PreferredSize, { 150, 60 } );</div>
</div><!-- fragment --><p><b>control with explicit size hint</b></p>
<div class="image">
<img src="size-hints-2.png" alt=""/>
<div class="caption">
Image with explicit size hint</div></div>
    <p>When dealing with standard controls or layouts, the size hints don’t need to be specified explicitly, as it can be deduced from its standard values, as seen in the example above.</p>
<p>The actual size of a UI element also depends on its size policy, see the next topic.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Size policies</h2>
<p>Size policies define the way UI elements can change their size depending on the available space. Imagine a UI with a top bar and a main content area: When a status bar at the bottom is to be faded in, the top bar and main content have less space to display. One way to deal with this would be to leave the top bar at the same size and shrink the main area. This can be achieved with size policies: The top bar would have a vertical size policy of <code>Fixed</code>, while the main area would be <code>Preferred</code>, meaning it can grow and shrink.</p>
<p>The size policies of QSkinny correspond to the <em><a href="https://doc.qt.io/qt-5/qsizepolicy.html#Policy-enum">https://doc.qt.io/qt-5/qsizepolicy.html#Policy-enum</a>[size policies from QtWidgets]</em>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><code>QskSizePolicy::Policy</code>   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Fixed</code>   </td><td class="markdownTableBodyNone">The control has a fixed size and can neither grow nor shrink.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Minimum</code>   </td><td class="markdownTableBodyNone">The control cannot shrink beyond its minimum size, but it can grow if needed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Maximum</code>   </td><td class="markdownTableBodyNone">The control cannot grow beyond its maximum size, but it can shrink if needed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Preferred</code>   </td><td class="markdownTableBodyNone">The control can grow and shrink, but it should be of the size given by <code>sizeHint()</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MinimumExpanding</code>   </td><td class="markdownTableBodyNone">The control cannot shrink beyond its minimum size, but it can grow and should get as much space as possible.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Expanding</code>   </td><td class="markdownTableBodyNone">The control can shrink and grow, and it should get as much space as possible.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Ignored</code>   </td><td class="markdownTableBodyNone">The <code>sizeHint()</code> is ignored, and the control will get as much space as possible.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Constrained</code>   </td><td class="markdownTableBodyNone">The size of the control depends on a constraint, i.e. the width is depending on the height or vice versa. For this policy and the other <code>Constrained*</code> ones below, <code><a class="el" href="classQskControl.html#a3d70b8e85160cd239393cfb734cdd751">QskControl::widthForHeight()</a></code> or <code><a class="el" href="classQskControl.html#a4e66fe7677acfedbae22ba2fbd4e027b">QskControl::heightForWidth()</a></code> will be queried.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ConstrainedMinimum</code>   </td><td class="markdownTableBodyNone">The size of the control depends on a constraint, but it can grow if needed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ConstrainedMaximum</code>   </td><td class="markdownTableBodyNone">The size of the control depends on a constraint, but it can shrink if needed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ConstrainedPreferred</code>   </td><td class="markdownTableBodyNone">The size of the control depends on a constraint, but it can grow and srhink if needed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ConstrainedMinimumExpanding</code>   </td><td class="markdownTableBodyNone">The size of the control depends on a constraint, but it can grow and should get as much space as possible.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ConstrainedExpanding</code>   </td><td class="markdownTableBodyNone">The size of the control depends on a constraint, and it should get as much space as possible.   </td></tr>
</table>
<p>All the <code>Constrained*</code> policies correspond to Qt’s <a href="https://doc.qt.io/qt-5/qsizepolicy.html#hasHeightForWidth">QSizePolicy::hasHeightForWidth()</a> or <a href="https://doc.qt.io/qt-5/qsizepolicy.html#hasWidthForHeight">QSizePolicy::hasWidthForHeight()</a> flag. E.g. if a control has a horizontal size policy of <code>Constrained</code> and a vertical size policy of <code>Fixed</code>, it will call <code>widthForHeight()</code> to determine the width that corresponds to the height.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Example</h3>
<p>Below is an example of two buttons with different size policies. In this case only the horizontal size policies are considered; the vertical size policies behave correspondingly.</p>
<div class="fragment"><div class="line">auto horizontalBox = new QskLinearBox( Qt::Horizontal );</div>
<div class="line"> </div>
<div class="line">auto* label1 = new QskTextLabel( &quot;size policy: fixed&quot; );</div>
<div class="line">label1-&gt;setSizePolicy( Qt::Horizontal, QskSizePolicy::Fixed );</div>
<div class="line">horizontalBox-&gt;addItem( label1 );</div>
<div class="line"> </div>
<div class="line">auto* label2 = new QskTextLabel( &quot;size policy: minimum&quot; );</div>
<div class="line">label2-&gt;setSizePolicy( Qt::Horizontal, QskSizePolicy::Minimum );</div>
<div class="line">horizontalBox-&gt;addItem( label2 );</div>
<div class="line">...</div>
</div><!-- fragment --><p>By default the width of the buttons is determined by its text plus its margins:</p>
<p><b>Size policies with preferred size</b></p>
<div class="image">
<img src="size-policies-horizontal-minimum-1.png" alt=""/>
<div class="caption">
Fixed vs. Minimum size policy</div></div>
    <p>After growing the window horizontally, the button with the Fixed horizontal size policy keeps its width, while the button with the Minimum policy will grow:</p>
<p><b>Size policies when increasing window width</b></p>
<div class="image">
<img src="size-policies-horizontal-minimum-2.png" alt=""/>
<div class="caption">
Fixed vs. Minimum size policy</div></div>
    <p>When shrinking the window below its original size, both buttons stay with their width: The one on the left because of its <code>Fixed</code> size policy, and the one on the right because it won’t shrink below its original size due to the <code>Minimum</code> size policy.</p>
<p><b>Size policies when shrinking window width</b></p>
<div class="image">
<img src="size-policies-horizontal-minimum-3.png" alt=""/>
<div class="caption">
Fixed vs. Minimum size policy</div></div>
    <p>If we change the policy of the right button to <code>Preferred</code>, it will shrink below its original size (even though the text is too wide now):</p>
<div class="fragment"><div class="line">label2-&gt;setSizePolicy( Qt::Horizontal, QskSizePolicy::Preferred );</div>
<div class="line">label2-&gt;setText( &quot;size policy: preferred&quot; );</div>
</div><!-- fragment --><p><b>Size policies when changing to preferred size policy</b></p>
<div class="image">
<img src="size-policies-horizontal-minimum-4.png" alt=""/>
<div class="caption">
Fixed vs. Minimum size policy</div></div>
    <h2><a class="anchor" id="autotoc_md17"></a>
Types of layouts</h2>
<p>There are different types of layouts that can group UI elements together. Internally, layouts use the <code>layoutRect()</code> method to determine the available space to place its children.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Linear layouts (QskLinearBox)</h3>
<p>A linear layout can group elements either horizontally or vertically, as in the images below.</p>
<div class="fragment"><div class="line">auto horizontalBox = new QskLinearBox( Qt::Horizontal );</div>
<div class="line"> </div>
<div class="line">auto* label1 = new QskTextLabel( &quot;control 1&quot; );</div>
<div class="line">horizontalBox-&gt;addItem( label1 );</div>
<div class="line"> </div>
<div class="line">auto* label2 = new QskTextLabel( &quot;control 2&quot; );</div>
<div class="line">horizontalBox-&gt;addItem( label2 );</div>
<div class="line"> </div>
<div class="line">auto* label3 = new QskTextLabel( &quot;control 3&quot; );</div>
<div class="line">horizontalBox-&gt;addItem( label3 );</div>
<div class="line">...</div>
</div><!-- fragment --><p><b>Horizontal layout</b></p>
<div class="image">
<img src="layout-horizontal.png" alt=""/>
<div class="caption">
Horizontal layout</div></div>
    <div class="fragment"><div class="line">auto verticalBox = new QskLinearBox( Qt::Vertical );</div>
<div class="line"> </div>
<div class="line">auto* label1 = new QskTextLabel( &quot;control 1&quot; );</div>
<div class="line">verticalBox-&gt;addItem( label1 );</div>
<div class="line"> </div>
<div class="line">auto* label2 = new QskTextLabel( &quot;control 2&quot; );</div>
<div class="line">verticalBox-&gt;addItem( label2 );</div>
<div class="line"> </div>
<div class="line">auto* label3 = new QskTextLabel( &quot;control 3&quot; );</div>
<div class="line">verticalBox-&gt;addItem( label3 );</div>
<div class="line">...</div>
</div><!-- fragment --><p><b>Vertical layout</b></p>
<div class="image">
<img src="layout-vertical.png" alt=""/>
<div class="caption">
Vertical layout</div></div>
    <h3><a class="anchor" id="autotoc_md19"></a>
Grid layouts (QskGridBox)</h3>
<p>Grid layouts are like linear layouts, but 2 dimensional, and support laying out UI controls in a grid, including spanning columns and rows.</p>
<div class="fragment"><div class="line">auto* gridBox = new QskGridBox;</div>
<div class="line"> </div>
<div class="line">auto* label1 = new QskTextLabel( &quot;control 1&quot; );</div>
<div class="line">gridBox-&gt;addItem( label1, 0, 0 ); // last two arguments are row and column</div>
<div class="line"> </div>
<div class="line">auto* label2 = new QskTextLabel( &quot;control 2&quot; );</div>
<div class="line">gridBox-&gt;addItem( label2, 0, 1 );</div>
<div class="line"> </div>
<div class="line">auto* label3 = new QskTextLabel( &quot;control 3&quot; );</div>
<div class="line">gridBox-&gt;addItem( label3, 0, 2 );</div>
<div class="line"> </div>
<div class="line">auto* label4 = new QskTextLabel( &quot;control 4&quot; );</div>
<div class="line">gridBox-&gt;addItem( label4, 1, 0, 1, 2 ); // additional arguments are rowSpan and columnSpan</div>
<div class="line"> </div>
<div class="line">auto* label5 = new QskTextLabel( &quot;control 5&quot; );</div>
<div class="line">gridBox-&gt;addItem( label5, 1, 2 );</div>
<div class="line"> </div>
<div class="line">auto* label6 = new QskTextLabel( &quot;control 6&quot; );</div>
<div class="line">gridBox-&gt;addItem( label6, 2, 0 );</div>
<div class="line"> </div>
<div class="line">auto* label7 = new QskTextLabel( &quot;control 7&quot; );</div>
<div class="line">gridBox-&gt;addItem( label7, 2, 1, 1, 2 );</div>
</div><!-- fragment --><p><b>Grid layout</b></p>
<div class="image">
<img src="layout-grid.png" alt=""/>
<div class="caption">
Grid layout</div></div>
    <h3><a class="anchor" id="autotoc_md20"></a>
Stack layouts (QskStackBox)</h3>
<p>Stack layouts allow for items to be arranged on top of each other. Usually there is one current (visible) item, while the rest of the items are hidden below the current one:</p>
<div class="fragment"><div class="line">auto* stackBox = new QskStackBox;</div>
<div class="line"> </div>
<div class="line">auto* label1 = new QskTextLabel( &quot;control 1&quot; );</div>
<div class="line">label1-&gt;setBackgroundColor( Qt::blue );</div>
<div class="line">stackBox-&gt;addItem( label1 );</div>
<div class="line"> </div>
<div class="line">auto* label2 = new QskTextLabel( &quot;control 2&quot; );</div>
<div class="line">label2-&gt;setBackgroundColor( Qt::cyan );</div>
<div class="line">stackBox-&gt;addItem( label2 );</div>
<div class="line"> </div>
<div class="line">auto* label3 = new QskTextLabel( &quot;control 3&quot; );</div>
<div class="line">label3-&gt;setBackgroundColor( Qt::magenta );</div>
<div class="line">stackBox-&gt;addItem( label3 );</div>
<div class="line"> </div>
<div class="line">stackBox-&gt;setCurrentIndex( 2 );</div>
<div class="line">...</div>
</div><!-- fragment --><p><b>Stack layout (symbolized)</b></p>
<div class="image">
<img src="layout-stack.png" alt=""/>
<div class="caption">
Stack layout</div></div>
    <p>In this example, "control 3" is stacked on top of the blue and the cyan control. Controls in a stacked layout can be of different sizes.</p>
<p><b>NOTE</b>: The image above is just for illustrating purposes. In practice the topmost control ("control 3" here) is completely covering the ones below it.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
QskControl::autoLayoutChildren()</h3>
<p>When the <code><a class="el" href="classQskControl.html#afd0f572601d726d8b5f36e45185f6dba">QskControl::autoLayoutChildren()</a></code> flag is set, the control will recalculate the geometry of its children whenever the item is updating its layout.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Stretch factors</h2>
<p>Stretch factors allow layouts to keep a size ratio for their elements. Let’s say a horizontal layout contains two elements, and when filling up additional space, the second element should always have twice the width of the first element. Then the first element should have a stretch factor of 1 and the second element a factor of 2.</p>
<p>Stretch factors are set on the layout rather than on the controls itself:</p>
<div class="fragment"><div class="line">auto horizontalBox = new QskLinearBox( Qt::Horizontal );</div>
<div class="line"> </div>
<div class="line">auto* label1 = new QskTextLabel( &quot;stretch factor 1&quot; );</div>
<div class="line">horizontalBox-&gt;addItem( label1 );</div>
<div class="line">horizontalBox-&gt;setStretchFactor( label1, 1 );</div>
<div class="line"> </div>
<div class="line">auto* label2 = new QskTextLabel( &quot;stretch factor 2&quot; );</div>
<div class="line">horizontalBox-&gt;addItem( label2 );</div>
<div class="line">horizontalBox-&gt;setStretchFactor( label2, 2 );</div>
<div class="line"> </div>
<div class="line">...</div>
</div><!-- fragment --><p>When the layout has all the space it needs (but not more), both elements are rendered with their preferred size:</p>
<p><b>Stretch factors with preferred size</b></p>
<div class="image">
<img src="stretch-factors-1.png" alt=""/>
<div class="caption">
Stretch factors preferred size</div></div>
    <p>When the layout gets more width, the stretch factors come into play:</p>
<p><b>A stretch factor of 1:2</b></p>
<div class="image">
<img src="stretch-factors-2.png" alt=""/>
<div class="caption">
Stretch factors increasing width</div></div>
    <p>No matter how wide the layout is, the aspect ratio of 1:2 will always be kept, meaning that the label on the left will get 33% of the space, and the label on the right 67%:</p>
<p><b>A stretch factor of 1:2 with different widths</b></p>
<div class="image">
<img src="stretch-factors-3.png" alt=""/>
<div class="caption">
Stretch factors even more width</div></div>
    <p>Stretch factors in QSkinny are the same as in the Qt Graphics View Framework, see <a href="https://doc.qt.io/qt-5/qgraphicslinearlayout.html#stretch-factor-in-qgraphicslinearlayout">https://doc.qt.io/qt-5/qgraphicslinearlayout.html#stretch-factor-in-qgraphicslinearlayout</a>[Stretch Factor in QGraphicsLinearLayout].</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Nesting layouts</h2>
<p>In a real-world application it is typical to nest several layouts in each other. The example below depicts a UI with a top bar and menu items on the left:</p>
<p><b>A UI with nested layouts</b></p>
<div class="image">
<img src="nesting-layouts.png" alt=""/>
<div class="caption">
Nested layouts</div></div>
    <p>The code to produce the above UI could look like this (setting colors etc. omitted for brevity):</p>
<div class="fragment"><div class="line">auto* outerBox = new QskLinearBox( Qt::Vertical );</div>
<div class="line"> </div>
<div class="line">auto* topBar = new QskLinearBox( Qt::Horizontal, outerBox );</div>
<div class="line"> </div>
<div class="line">auto* topLabel1 = new QskTextLabel( &quot;top bar label 1&quot;, topBar );</div>
<div class="line">auto* topLabel2 = new QskTextLabel( &quot;top bar label 2&quot;, topBar );</div>
<div class="line">auto* topLabel3 = new QskTextLabel( &quot;top bar label 3&quot;, topBar );</div>
<div class="line"> </div>
<div class="line">auto* mainBox = new QskLinearBox( Qt::Horizontal, outerBox );</div>
<div class="line"> </div>
<div class="line">auto* menuBox = new QskLinearBox( Qt::Vertical, mainBox );</div>
<div class="line"> </div>
<div class="line">auto* menuLabel1 = new QskTextLabel( &quot;menu 1&quot;, menuBox );</div>
<div class="line">auto* menuLabel2 = new QskTextLabel( &quot;menu 2&quot;, menuBox );</div>
<div class="line">auto* menuLabel3 = new QskTextLabel( &quot;menu 3&quot;, menuBox );</div>
<div class="line"> </div>
<div class="line">auto* mainText = new QskTextLabel( &quot;here main area&quot;, mainBox );</div>
<div class="line">...</div>
</div><!-- fragment --><p>Here we have an outer vertical layout which divides the content into a top bar and a main box. The top bar itself consists of a horizontal layout with 3 buttons, while the main area is split into a left part with menu buttons and a right part for the main area. That left part with the menu buttons is again a vertical layout.</p>
<p>The following diagram makes the layouts visible:</p>
<p><b>The layout structure of the UI</b></p>
<div class="image">
<img src="nesting-layouts-architecture.png" alt=""/>
<div class="caption">
Nested layouts architecture</div></div>
    <h2><a class="anchor" id="autotoc_md24"></a>
Anchoring in QSkinny</h2>
<p>TODO</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Skins, Skin hints and Skinlets</h1>
<p>Skins, Skin hints and Skinlets allow the user to define how specific controls looke like. Controls are drawn on the screen by the skinlet, and therefore it will read information from both the control itself as well as read the skin hints from the skin:</p>
<p><b>Skinlets query the control and the skin</b></p>
<div class="image">
<img src="skins-1.png" alt=""/>
<div class="caption">
Styling controls</div></div>
    <p>For instance, a button skinlet will read the margins from the skin and the text to render from the button.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Skins</h2>
<p>Skins are a way to define a look and feel for a whole set of UI controls, e.g. a night time vs. day time skin, skins for different brands or an Android Material skin. They contain all kinds of properties (i.e. skin hints) like colors, margins, fonts and more.</p>
<div class="fragment"><div class="line">class MySkin : public QskSkin</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    MySkin( QObject* parent = nullptr ) : QskSkin( parent )</div>
<div class="line">    {</div>
<div class="line">        // here define the skin with skin hints</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The example below shows different implementations for a push button: One has a traditional desktop skin, the other is a flat button with a skin often found in mobile devices.</p>
<p><b>desktop style button</b></p>
<div class="image">
<img src="skinlets-button-1.png" alt=""/>
<div class="caption">
desktop style button</div></div>
    <p><b>flat button</b></p>
<div class="image">
<img src="skinlets-button-2.png" alt=""/>
<div class="caption">
flat button</div></div>
    <h2><a class="anchor" id="autotoc_md27"></a>
Skin hints</h2>
<p>Each instance of a button will have unique properties like its text or icon file name, but all buttons will have common properties like the (default) background color and font size. These common properties are called skin hints, and are defined in a skin. Skin hints are either colors, e.g. the background color of a button, metrics (e.g. padding) or flags (e.g. text alignment).</p>
<p>Skin hints being part of a skin means that each skin can have different skin hints:</p>
<p>All buttons in a day time-like skin would have a light background color and dark text color, while a night time skin would have a dark background color and light text color by default.</p>
<p>Extending the <code>MySkin</code> example from above, here is an example of some skin hints for a push button, setting the padding to 10 pixels, the background color to magenta and the text color to black:</p>
<div class="fragment"><div class="line">class MySkin : public QskSkin</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    MySkin( QObject* parent = nullptr ) : QskSkin( parent )</div>
<div class="line">    {</div>
<div class="line">        setGradient( QskPushButton::Panel, Qt::magenta );</div>
<div class="line">        setMargins( QskPushButton::Panel | QskAspect::Padding, 10 );</div>
<div class="line">        setColor( QskPushButton::Text, Qt::black );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>A button styled with skin hints</b></p>
<div class="image">
<img src="skin-hints.png" alt=""/>
<div class="caption">
Button with skin hints</div></div>
    <p>When writing a new skin, a developer needs to know which hints to set for which control. This usually depends on the control itself; however, since usually controls are broken down into the three primitives box, text and graphic, the methods for rendering each of them will take the following skin hints into account:</p>
<p>|======================================================================= |Primitive |Skin hint from <a class="el" href="classQskAspect.html" title="Lookup key for a QskSkinHintTable.">QskAspect</a> |Text |<code>Alignment</code>\ <code>Color</code>\ <code>TextColor</code>\ <code>StyleColor</code>\ <code>LinkColor</code>\ <code>Style</code>\ <code>FontRole</code></p>
<p>|Graphic |<code>Alignment</code>\ <code>GraphicRole</code></p>
<p>|Box | <code>Margin</code>\ <code>Metric</code> | <code>Border</code>\ <code>Color</code> | <code>Border</code>\ <code>Color</code>\ <code>Metric</code> | <code>Shape</code> |=======================================================================</p>
<p>Some special cases exist where elements other than the primitives above are used.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
States and animations</h3>
<p>Skin hints can also depend on the state a control is in: Buttons for instance can be in a <code>Pressed</code> or <code>Hovered</code> state. For such cases, skin hints cannot only be set on a subcontrol, but also be made dependent on a specific state. In the example below we define the background color of the button to be magenta in the default state and cyan in the <code>Hovered</code> state.</p>
<p>When dealing with states, QSkinny allows for animations between those (and other entities like skins). The example below adds a different color for the <code>Hovered</code> state and an animation when transitioning between the background colors. The duration is set to be one second (1000 milliseconds in the <code>setAnimation()</code> call below). Now when a user will hover over the button, there will be a smooth animation from magenta to cyan interpolating between the colors. Without the <code>setAnimation()</code> call, the button would just switch to magenta when hovered right away.</p>
<div class="fragment"><div class="line">class MySkin : public QskSkin</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    MySkin( QObject* parent = nullptr ) : QskSkin( parent )</div>
<div class="line">    {</div>
<div class="line">        setGradient( QskPushButton::Panel, Qt::magenta );</div>
<div class="line">        setMargins( QskPushButton::Panel | QskAspect::Padding, 10 );</div>
<div class="line">        setColor( QskPushButton::Text, Qt::black );</div>
<div class="line"> </div>
<div class="line">        setGradient( QskPushButton::Panel | QskPushButton::Hovered, Qt::cyan );</div>
<div class="line">        setAnimation( QskPushButton::Panel | QskAspect::Color, 1000 );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>button in normal state</b></p>
<div class="image">
<img src="skin-hints-states-1.png" alt=""/>
<div class="caption">
button in normal state</div></div>
    <p><b>button in hovered state</b></p>
<div class="image">
<img src="skin-hints-states-2.png" alt=""/>
<div class="caption">
button in hovered state</div></div>
    <h3><a class="anchor" id="autotoc_md29"></a>
Local skin hints</h3>
<p>It is possible to set local skin hints on specific controls to override skin-wide settings:</p>
<div class="fragment"><div class="line">auto* label1 = new QskTextLabel( &quot;control 1&quot; );</div>
<div class="line">label1-&gt;setMargins( 20 );</div>
<div class="line">label1-&gt;setBackgroundColor( Qt::blue );</div>
</div><!-- fragment --><p>In general it is recommended to set the skin hints in the skin rather than on the control locally, in order to separate the style from the implementation, and to allow switching between skins. How to write controls that are themable is explained in the section about <a href="Writing-own-controls.html">writing own controls</a>.</p>
<p>Taking animations and local skin hints into account, the architecture diagram now looks like this:</p>
<p><b>Skinlets can also read from local skinlets and animators</b></p>
<div class="image">
<img src="skins-2.png" alt=""/>
<div class="caption">
Animators and local skin hints</div></div>
    <h2><a class="anchor" id="autotoc_md30"></a>
Skinlets</h2>
<p>A skinlet is in charge of drawing a control on the screen, similar to a Delegate in QML. It will read all the hints it needs from either the control itself or the skin, then it will draw the subcontrols that represent the control: In the sample case of a button, the skinlet will first draw the background panel, potentially consisting of a rectangle with a fill color. Then it will draw the text of the button, and last it will draw an icon, in case the button has one set.</p>
<p>Each skin can have a different skinlet to draw a control. Often the skinlet is the same across different skins and the skins only differ in skin hints, e.g. buttons having different fonts. However, it is also possible to have completely different skinlets per skin. This ensures a separation of application code instantiating the controls itself from the visual representation of the controls.</p>
<p>QSkinny already contains implementations of many common controls like text labels, buttons and so on. However, some custom controls might need to be written from scratch, including the skinlet; for an explanation on how to do this, see the example of <a href="Writing-own-controls.html">writing own controls</a>.</p>
<p>For a closer look at how the skinlet draws the controls in the scene graph, see <a href="scene-graph.html">scene graph representations of controls</a>.</p>
<p>Of course each app has different controls and therefore there are also different skinlets, so a more complete version of the architecture diagram looks like this:</p>
<p><b>There is one skinlet for each atomic control</b></p>
<div class="image">
<img src="skins-3.png" alt=""/>
<div class="caption">
Animators and local skin hints</div></div>
    <h2><a class="anchor" id="autotoc_md31"></a>
Skin factories and switching between skins</h2>
<p>Skins are usually not created by the user directly, but by a skin factory. Such a factory keeps track of the skins registered in the system, and handles creating a new skin when the user switches them during application lifetime.</p>
<p>When having two skins called <code>MySkin</code> and <code>OtherSkin</code> in an app, the corresponding skin factory might look like this:</p>
<div class="fragment"><div class="line">class MySkinFactory : public QskSkinFactory</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    Q_OBJECT</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    QStringList skinNames() const override</div>
<div class="line">    {</div>
<div class="line">        return { &quot;MySkin&quot;, &quot;OtherSkin&quot; };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    QskSkin* createSkin( const QString&amp; skinName ) override</div>
<div class="line">    {</div>
<div class="line">        if ( skinName == &quot;MySkin&quot; )</div>
<div class="line">            return new MySkin;</div>
<div class="line"> </div>
<div class="line">        if ( skinName == &quot;OtherSkin&quot; )</div>
<div class="line">            return new OtherSkin;</div>
<div class="line"> </div>
<div class="line">        return nullptr;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>That skin factory has to be registered during app start; it is also a good idea to set a default skin right away:</p>
<div class="fragment"><div class="line">int main( int argc, char* argv[] )</div>
<div class="line">{</div>
<div class="line">    auto* skinFactory = new MySkinFactory;</div>
<div class="line">    qskSkinManager-&gt;registerFactory( &quot;MySkinFactory&quot;, skinFactory );</div>
<div class="line"> </div>
<div class="line">    QGuiApplication app( argc, argv );</div>
<div class="line"> </div>
<div class="line">    qskSetup-&gt;setSkin( &quot;MySkin&quot; );</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line">    QskWindow window;</div>
<div class="line">    window.show();</div>
<div class="line"> </div>
<div class="line">    return app.exec();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we can define the <code>OtherSkin</code> and define different skin hints for e.g. push buttons. Here we define the background color and padding to be different; also we configure buttons to have a blue border:</p>
<div class="fragment"><div class="line">class OtherSkin : public QskSkin</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    OtherSkin( QObject* parent = nullptr ) : QskSkin( parent )</div>
<div class="line">    {</div>
<div class="line">        setGradient( QskPushButton::Panel, Qt::cyan );</div>
<div class="line">        setMargins( QskPushButton::Panel | QskAspect::Padding, 15 );</div>
<div class="line">        setBoxBorderColors( QskPushButton::Panel, Qt::blue );</div>
<div class="line">        setBoxBorderMetrics( QskPushButton::Panel, 1 );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Switching between skins will change the look of <code><a class="el" href="classQskPushButton.html">QskPushButton</a></code> instances:</p>
<p><b>button in <code>MySkin</code> (as above)</b></p>
<div class="image">
<img src="skin-hints-states-1.png" alt=""/>
<div class="caption">
button in normal state</div></div>
    <p><b>button in <code>OtherSkin</code></b></p>
<div class="image">
<img src="skin-factory.png" alt=""/>
<div class="caption">
Styling controls</div></div>
    <h1><a class="anchor" id="autotoc_md32"></a>
(Scalable) graphics</h1>
<p>QSkinny offers support for scalable graphics, i.e. rendering SVGs that adapt to a specific size. This means that when a graphic is embedded in a layout, it can change its size when the layout is growing or shrinking, while still maintaining a correct aspect ratio.</p>
<p>Imagine the following code, which produces the image depicted below:</p>
<div class="fragment"><div class="line">auto horizontalBox = new QskLinearBox( Qt::Horizontal );</div>
<div class="line">horizontalBox-&gt;setPreferredSize( { 200, 75 } );</div>
<div class="line"> </div>
<div class="line">QImage image1( &quot;:/images/cloud.svg&quot; );</div>
<div class="line">QskGraphic graphic1 = QskGraphic::fromImage( image1 );</div>
<div class="line">auto* label1 = new QskGraphicLabel( graphic1, horizontalBox );</div>
<div class="line">label1-&gt;setSizePolicy( QskSizePolicy::ConstrainedPreferred, QskSizePolicy::Expanding );</div>
<div class="line"> </div>
<div class="line">QImage image2( &quot;:/images/train.svg&quot; );</div>
<div class="line">QskGraphic graphic2 = QskGraphic::fromImage( image2 );</div>
<div class="line">auto* label2 = new QskGraphicLabel( graphic2, horizontalBox );</div>
<div class="line">label2-&gt;setSizePolicy( QskSizePolicy::ConstrainedPreferred, QskSizePolicy::Expanding );</div>
<div class="line">...</div>
</div><!-- fragment --><p><b>graphics with preferred size</b></p>
<div class="image">
<img src="scalable-graphics-1.png" alt=""/>
<div class="caption">
Scalable graphics default</div></div>
    <p>When resizing the window, the graphics will scale according to the size available in the layout:</p>
<p><b>graphics bounded by width</b></p>
<div class="image">
<img src="scalable-graphics-2.png" alt=""/>
<div class="caption">
Scalable graphics bounded by width</div></div>
    <p><b>graphics bounded by height</b></p>
<div class="image">
<img src="scalable-graphics-3.png" alt=""/>
<div class="caption">
Scalable graphics bounded by height</div></div>
    <p>Since we set the horizontal size policy of the graphics to <code>ConstrainedPreferred</code>, the scaling is done through QskGraphic’s <code>widthForHeight()</code> methods to maintain the correct aspect ratio. If we had set the vertical policy to <code>ConstrainedPreferred</code> and the horizontal one to e.g. <code>Expanding</code>, the layout would have queried the <code>heightForWidth()</code> method instead.</p>
<p>Of course non-scalable graphics like PNGs and JPGs are also supported:</p>
<div class="fragment"><div class="line">QImage image( &quot;background.jpg&quot; );</div>
<div class="line">QskGraphic graphic = QskGraphic::fromImage( image );</div>
<div class="line">...</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
QSkinny - Using QSkinny and QML</h1>
<p>Combining QSkinny and QML is possible: Since both QML elements and QSkinny controls derive from <code>QQuickItem</code>, they can be combined and arranged in a common app. The <a href="https://github.com/uwerat/qskinny/tree/master/examples/buttons">https://github.com/uwerat/qskinny/tree/master/examples/buttons</a>[QSkinny buttons example] shows how QSkinny controls can be used from QML.</p>
<p>When using a QSkinny control, all the methods exposed as either properties, slots or invokables can be used in QML. For example, the QSkinny control <code><a class="el" href="classQskLinearBox.html" title="Layout stringing items in rows and columns.">QskLinearBox</a></code> defines the following properties:</p>
<p><b>CMakeLists.txt</b></p>
<div class="fragment"><div class="line">target_link_libraries(myapp PRIVATE </div>
<div class="line">    ...</div>
<div class="line">    Qsk::QmlExport)</div>
<div class="line">...</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>QSK_EXPORT <a class="code hl_class" href="classQskLinearBox.html">QskLinearBox</a> : <span class="keyword">public</span> <a class="code hl_class" href="classQskIndexedLayoutBox.html">QskIndexedLayoutBox</a></div>
<div class="line">{</div>
<div class="line">    Q_PROPERTY( Qt::Orientation orientation READ orientation WRITE setOrientation NOTIFY orientationChanged FINAL )</div>
<div class="line">    Q_PROPERTY( qreal spacing READ spacing WRITE setSpacing RESET resetSpacing NOTIFY spacingChanged FINAL )</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="ttc" id="aclassQskIndexedLayoutBox_html"><div class="ttname"><a href="classQskIndexedLayoutBox.html">QskIndexedLayoutBox</a></div><div class="ttdoc">Base class of layouts with index ordered elements.</div><div class="ttdef"><b>Definition</b> <a href="QskIndexedLayoutBox_8h_source.html#l00011">QskIndexedLayoutBox.h:12</a></div></div>
</div><!-- fragment --><p>The <code><a class="el" href="classQskLinearBox.html" title="Layout stringing items in rows and columns.">QskLinearBox</a></code> class is registered to QML as <code>Qsk.LinearBox</code> via Qt’s <code>qmlRegisterType</code>, so the exposed properties <code>orientation</code> and <code>spacing</code> can be used like this:</p>
<div class="fragment"><div class="line">Qsk.LinearBox</div>
<div class="line">{</div>
<div class="line">    orientation: Qt.Horizontal</div>
<div class="line">    spacing: 10</div>
<div class="line"> </div>
<div class="line">    // here define elements inside the box</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The full Buttons example is depicted below.</p>
<p><b>The buttons example shows how to mix QSkinny and QML</b></p>
<div class="image">
<img src="buttons-example.png" alt=""/>
<div class="caption">
Buttons example</div></div>
    <p>For more information on using C++ classes from QML, see the article about exposing attributes of {cpp} types to QML in the <a href="https://doc.qt.io/qt-5/qtqml-cppintegration-exposecppattributes.html">Qt documentation</a>.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
Writing own controls</h1>
<p>Writing own controls is either done by subclassing or compositing an existing displayable control like <code><a class="el" href="classQskTextLabel.html">QskTextLabel</a></code>, or by writing a completely new class including a skinlet, which is typically derived directly from <code><a class="el" href="classQskControl.html" title="Base class of all controls.">QskControl</a></code>.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Subclassing existing controls</h2>
<p>Let’s say an app is displaying a text label with a specific style at several different places, then it makes sense to subclass <code><a class="el" href="classQskTextLabel.html">QskTextLabel</a></code> and set the needed properties like font size etc. in the derived class:</p>
<div class="fragment"><div class="line">class TextLabel : public QskTextLabel</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    Q_OBJECT</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    TextLabel( const QString&amp; text, QQuickItem* parent = nullptr ) : QskTextLabel( text, parent )</div>
<div class="line">    {</div>
<div class="line">        setMargins( 15 );</div>
<div class="line">        setBackgroundColor( Qt::cyan );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>A subclassed control with local skin hints</b></p>
<div class="image">
<img src="subclassing-existing-controls.png" alt=""/>
<div class="caption">
Subclassing existing controls</div></div>
    <p>Then there is no need to set the margins and background color for every instance of the custom text label.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Making custom classes skinnable</h2>
<p>To make custom classes like the <code>TextLabel</code> class above skinnable, we need to define our own subcontrols and style them in our skin, in contrast to setting the values directly in the class. To be able to set specific values for our <code>TextLabel</code> class that are different from the generic <code><a class="el" href="classQskTextLabel.html">QskTextLabel</a></code>, we need to define our own subcontrols and substitute the generic subcontrols for them in an overriden method <code>effectiveSubcontrol()</code>:</p>
<div class="fragment"><div class="line">class TextLabel : public QskTextLabel</div>
<div class="line">{</div>
<div class="line">    QSK_SUBCONTROLS( Panel )</div>
<div class="line"> </div>
<div class="line">    TextLabel( const QString&amp; text, QQuickItem* parent = nullptr ) : QskTextLabel( text, parent )</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    QskAspect::Subcontrol effectiveSubcontrol( QskAspect::Subcontrol subControl ) const override final</div>
<div class="line">    {</div>
<div class="line">        if ( subControl == QskTextLabel::Panel )</div>
<div class="line">            return TextLabel::Panel;</div>
<div class="line"> </div>
<div class="line">        return subControl;</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>When the skinlet is drawing a <code>TextLabel</code> instance, it queries it for its subcontrols through <code>effectiveSubcontrol()</code> in order to style them properly. Now that we substitute the <code>QskTextLabel::Panel</code> for our <code>TextLabel::Panel</code>, we can style it accordingly in our skin, so we don’t need to set the local skin hints in the constructor of <code>TextLabel</code> anymore.</p>
<div class="fragment"><div class="line">class MySkin : public QskSkin</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    MySkin( QObject* parent = nullptr ) : QskSkin( parent )</div>
<div class="line">    {</div>
<div class="line">        setGradient( TextLabel::Panel, Qt::cyan );</div>
<div class="line">        setMargins( TextLabel::Panel | QskAspect::Padding, 15 );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>A subclassed control with skin hints defined in the skin</b></p>
<div class="image">
<img src="subclassing-existing-controls.png" alt=""/>
<div class="caption">
Subclassing existing controls</div></div>
    <p>The styling described above has the same effect as in the simpler example, but now the <code>TextLabel</code> control can be given a different style depending on the skin.</p>
<p>In our class we only set a custom skin hint for the panel, but as <code><a class="el" href="classQskTextLabel.html">QskTextLabel</a></code> also has a <code>Text</code> subcontrol, we could of course also define our own one for the text.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Compositing controls</h2>
<p>Controls can also be composited; e.g. when writing a class with a text label on the left and a graphic on the right side, it could look like this:</p>
<div class="fragment"><div class="line">class TextAndGraphic : public QskLinearBox</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    Q_OBJECT</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    TextAndGraphic( const QString&amp; text, const QString&amp; graphicName, QQuickItem* parent = nullptr )</div>
<div class="line">        : QskLinearBox( Qt::Horizontal, parent ),</div>
<div class="line">          m_textLabel( new QskTextLabel( text, this ) )</div>
<div class="line">    {</div>
<div class="line">        addItem( m_textLabel );</div>
<div class="line"> </div>
<div class="line">        QImage image( QString( &quot;:/images/%1.svg&quot; ).arg( graphicName ) );</div>
<div class="line">        auto graphic = QskGraphic::fromImage( image );</div>
<div class="line"> </div>
<div class="line">        m_graphicLabel = new QskGraphicLabel( graphic );</div>
<div class="line">        m_graphicLabel-&gt;setExplicitSizeHint( Qt::PreferredSize, { 30, 30 } );</div>
<div class="line">        addItem( m_graphicLabel );</div>
<div class="line"> </div>
<div class="line">        setAutoLayoutChildren( true );</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    QskTextLabel* m_textLabel;</div>
<div class="line">    QskGraphicLabel* m_graphicLabel;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This allows for easy instantiation of the class with a text and a file name for the graphic:</p>
<div class="fragment"><div class="line">auto* textAndGraphic = new TextAndGraphic( &quot;Text&quot;, &quot;cloud&quot; );</div>
</div><!-- fragment --><p><b>A composited control</b></p>
<div class="image">
<img src="compositing-controls.png" alt=""/>
<div class="caption">
Compositing controls</div></div>
    <h2><a class="anchor" id="autotoc_md38"></a>
Writing controls with a skinlet</h2>
<p>QSkinny already comes with controls like text labels, list views, buttons etc. When there is a completely new control to be written that cannot be subclassed or composited, the skinlet for the class needs to be implemented as well.</p>
<h3><a class="anchor" id="autotoc_md39"></a>
Writing the class</h3>
<p>For demo purposes we create a class called <code>CustomShape</code> which shall display an outer circle and an inner circle, with minimal API. There are only 2 subcontrols that will be painted in the skinlet later:</p>
<div class="fragment"><div class="line">class CustomShape : public QskControl</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    QSK_SUBCONTROLS( Panel, InnerShape )</div>
<div class="line"> </div>
<div class="line">    CustomShape( QQuickItem* parent = nullptr ) : QskControl( parent )</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md40"></a>
Writing the skinlet</h3>
<p>Writing the skinlet is the hard part of the work. We need the following things in our skinlet:</p>
<ul>
<li>A definition of node roles. They typically correspond to subcontrols from the control, so since in our case we have a subcontrol <code>Panel</code> and <code>InnerShape</code>, there will be the node roles <code>PanelRole</code> and <code>InnerShapeRole</code>. The node roles are often set in the constructor of the class.</li>
</ul>
<p><b>❗ IMPORTANT</b>\ The constructor of the skinlet needs to be invokable!</p>
<div class="fragment"><div class="line">class CustomShapeSkinlet : public QskSkinlet</div>
<div class="line">{</div>
<div class="line">    Q_GADGET</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    enum NodeRole</div>
<div class="line">    {</div>
<div class="line">        PanelRole, InnerShapeRole</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Q_INVOKABLE CustomShapeSkinlet( QskSkin* skin = nullptr ) : QskSkinlet( skin )</div>
<div class="line">    {</div>
<div class="line">        setNodeRoles( { PanelRole, InnerShapeRole } );</div>
<div class="line">    }</div>
</div><!-- fragment --><ul>
<li>The enclosing rectangle for each subcontrol. This can be just the <code>contentsRect</code>, but we can define it more accurately if we want by applying some metrics. If the code below is hard to understand, the important thing to take away from it is that different subcontrols can have different enclosing rectangles.</li>
</ul>
<div class="fragment"><div class="line">QRectF subControlRect( const QskSkinnable* skinnable, const QRectF&amp; contentsRect, QskAspect::Subcontrol subControl ) const override</div>
<div class="line">{</div>
<div class="line">    const auto* customShape = static_cast&lt; const CustomShape* &gt;( skinnable );</div>
<div class="line"> </div>
<div class="line">    if ( subControl == CustomShape::Panel )</div>
<div class="line">    {</div>
<div class="line">        return contentsRect;</div>
<div class="line">    }</div>
<div class="line">    else if ( subControl == CustomShape::InnerShape )</div>
<div class="line">    {</div>
<div class="line">        const auto margins = customShape-&gt;marginsHint( CustomShape::InnerShape );</div>
<div class="line">        return contentsRect.marginsRemoved( margins );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return QskSkinlet::subControlRect( skinnable, contentsRect, subControl );</div>
</div><!-- fragment --><ul>
<li>The code to actually draw the nodes. In our case of an outer circle and an inner circle, the code for each subcontrol / node role is quite similar. The method <code>updateSubNode()</code>, which is reimplemented from <code>QQuickItem</code>, is called once for each node role. The code below again might not be straight forward to understand, the gist of it is that for each node role we draw a circle by creating a <code>BoxNode</code>.</li>
</ul>
<div class="fragment"><div class="line">protected:</div>
<div class="line">    QSGNode* updateSubNode( const QskSkinnable* skinnable, quint8 nodeRole, QSGNode* node ) const override</div>
<div class="line">    {</div>
<div class="line">        const auto* customShape = static_cast&lt; const CustomShape* &gt;( skinnable );</div>
<div class="line"> </div>
<div class="line">        switch ( nodeRole )</div>
<div class="line">        {</div>
<div class="line">            case PanelRole:</div>
<div class="line">            {</div>
<div class="line">                auto panelNode = static_cast&lt; QskBoxNode* &gt;( node );</div>
<div class="line"> </div>
<div class="line">                ...</div>
<div class="line">                const auto panelRect = subControlRect( customShape, customShape-&gt;contentsRect(), CustomShape::Panel );</div>
<div class="line">                const qreal radius = panelRect.width() / 2;</div>
<div class="line">                panelNode-&gt;setBoxData( panelRect, shapeMetrics, borderMetrics, borderColors, gradient );</div>
<div class="line"> </div>
<div class="line">                return panelNode;</div>
<div class="line">            }</div>
<div class="line">            case InnerShapeRole:</div>
<div class="line">            {</div>
<div class="line">                auto innerNode = static_cast&lt; QskBoxNode* &gt;( node );</div>
<div class="line"> </div>
<div class="line">                ...</div>
<div class="line">                const auto innerRect = subControlRect( customShape, customShape-&gt;contentsRect(), CustomShape::InnerShape );</div>
<div class="line">                const qreal radius = innerRect.width() / 2;</div>
<div class="line">                innerNode-&gt;setBoxData( innerRect, shapeMetrics, borderMetrics, borderColors, gradient );</div>
<div class="line"> </div>
<div class="line">                return innerNode;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        return QskSkinlet::updateSubNode( skinnable, nodeRole, node );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md41"></a>
Connecting class and skinlet</h3>
<p>In our skin, we need to declare that the skinlet above will be responsible of drawing our control via <code>declareSkinlet</code>. Also, we can style our control with skin hints:</p>
<div class="fragment"><div class="line">class MySkin : public QskSkin</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    MySkin( QObject* parent = nullptr ) : QskSkin( parent )</div>
<div class="line">    {</div>
<div class="line">       declareSkinlet&lt; CustomShape, CustomShapeSkinlet &gt;();</div>
<div class="line"> </div>
<div class="line">       setGradient( CustomShape::Panel, Qt::blue );</div>
<div class="line">       setMargins( CustomShape::InnerShape, 20 );</div>
<div class="line">       setGradient( CustomShape::InnerShape, Qt::magenta );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>SkinFactories etc. are again omitted here. Finally we can draw our control; the effort might seem excessive, but we wrote the control with all capabilities of styling; in addition, the control will react to size changes properly. A simpler version with hardcoded values for margins, colors etc. can be written with less code.</p>
<p><b>A class with an own skinlet</b></p>
<div class="image">
<img src="control-with-skinlet.png" alt=""/>
<div class="caption">
Control with skinlet</div></div>
    <h1><a class="anchor" id="autotoc_md42"></a>
Scene graph representations of controls</h1>
<p>Each control that is displayed on the screen consists of one or more scene graph nodes. Those nodes can be either basic shapes like rectangles, or they can contain other information like positioning (used with transform nodes), opacity or clipping.</p>
<p>The source code below shows a minimal example displaying a button:</p>
<div class="fragment"><div class="line">auto* button = new QskPushButton( &quot;button&quot; );</div>
<div class="line"> </div>
<div class="line">QskWindow window;</div>
<div class="line">window.addItem( button );</div>
<div class="line">window.show();</div>
</div><!-- fragment --><p>For this example, the scene graph will contain the following nodes:</p>
<p><b>Scene graph representation of a button</b></p>
<div class="image">
<img src="skins-sg-1.png" alt=""/>
<div class="caption">
Scene graph nodes for a button</div></div>
    <p>The top two nodes (root and Quick root item) are created for every QtQuick application. The button itself consists of 5 nodes in our case: One root note (<code>button node</code>), one node just to group its children (just labeled <code>node</code>), one geometry node for drawing the background (<code>panel node</code>), one transform node for setting the position of the text and another geometry node for displaying the text (<code>text node</code>).</p>
<p>For an explanation of the different scene graph node types, see the Qt documentation of <a href="https://doc.qt.io/qt-5/qsgnode.html#NodeType-enum">QSGNode::NodeType</a>.</p>
<p>The example above is the simplest form of a button, in practice there might be more nodes per control, for instance an opacity node or a clip node.</p>
<p>Now we add more elements to the UI by putting the button inside a layout (<code><a class="el" href="classQskBox.html">QskBox</a></code>):</p>
<div class="fragment"><div class="line">auto* box = new QskBox;</div>
<div class="line">auto* button = new QskPushButton( &quot;button&quot;, box );</div>
<div class="line"> </div>
<div class="line">QskWindow window;</div>
<div class="line">window.addItem( box );</div>
<div class="line">window.show();</div>
</div><!-- fragment --><p>Then the scene graph has the following structure:</p>
<p><b>Scene graph representation of a button inside a box</b></p>
<div class="image">
<img src="skins-sg-2.png" alt=""/>
<div class="caption">
Scene graph nodes for a button in a box</div></div>
    <p>Here we can see that since the box is a parent of the button, the <code>box node</code> is also a parent of the <code>button node</code> in the scene graph. Also, the box has two child nodes: The button, which is the same as in the earlier example, and a node for the panel of the box, in case the panel itself has a background color.</p>
<p>In a more complicated UI with multiple elements and more advanced layouts, the number of scene graph nodes can be quite high. This is why QSkinny tries to create as little nodes as possible and reuse as many as it can.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Building QSkinny for WebAssembly (Wasm)</h1>
<h2><a class="anchor" id="autotoc_md44"></a>
Build Qt for Wasm</h2>
<p>Build Qt for Wasm from source as described here: <a href="https://doc.qt.io/qt-6/wasm.html#building-qt-from-source">https://doc.qt.io/qt-6/wasm.html#building-qt-from-source</a> ; The verified Qt version for QSkinny as of this writing was 6.6.0. It might also work to use a downloaded version of Qt for Wasm, but some additional libraries will need to be built. After configuring Qt as described in the link above, for QSkinny you will need the qtbase, qtdeclarative, qtshadertools and qtsvg modules. Assuming the Emscripten SDK in <code>~/dev/emscripten</code> and Qt in <code>~/dev/qt6</code>, Qt can be compiled the following way:</p>
<div class="fragment"><div class="line">cd ~/dev/qt6</div>
<div class="line">source &quot;~/dev/emsdk/emsdk_env.sh&quot;</div>
<div class="line">./configure -platform wasm-emscripten -qt-host-path ~/Qt/6.6.0/gcc_64/ -prefix $PWD/qtbase -submodules qtbase,qtdeclarative,qtshadertools,qtsvg</div>
<div class="line">cmake --build . -t qtbase -t qtdeclarative -t qtshadertools -t qtsvg</div>
</div><!-- fragment --><p>This will install all required libs in <code>~/dev/qt6/qtbase/lib</code>.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Build QSkinny for Wasm</h2>
<p>With the Qt version from above QSkinny can be built for WAsm, assuming it has been checked out at <code>~/dev/qskinny</code>. Note the configuration option <code>BUILD_QSKDLL=OFF</code> for static builds:</p>
<div class="fragment"><div class="line">mkdir -p ~/dev/qskinny-wasm-build</div>
<div class="line">source &quot;~/dev/emsdk/emsdk_env.sh&quot;</div>
<div class="line">~/dev/qt6/qtbase/bin/qt-cmake -S ~/dev/qskinny -B ~/dev/qskinny-wasm-build -DBUILD_QSKDLL=OFF</div>
<div class="line">make</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
Run QSkinny for Wasm</h2>
<p>Qt creates the HTML wrappers automatically, so there is not much to do except letting Emscripten start the server and open our app in the browser:</p>
<div class="fragment"><div class="line">/usr/bin/python3 ~/dev/emsdk/upstream/emscripten/emrun.py --browser firefox --port 30001 --no_emrun_detect  ~/dev/qskinny-wasm-build/examples/bin/iotdashboard.html</div>
</div><!-- fragment --><p><b>The IOT dashboard example in a browser</b></p>
<div class="image">
<img src="iotdashboard-wasm.png" alt=""/>
<div class="caption">
The IOT dashboard example in a browser</div></div>
     </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
